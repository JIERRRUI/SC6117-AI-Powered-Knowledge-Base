export interface Note {
  id: string;
  title: string;
  content: string; // Markdown content
  tags: string[];
  createdAt: string;
  folder: string; // Virtual folder path
}

export enum SearchMode {
  EXACT = "EXACT", // Grep-style
  SEMANTIC = "SEMANTIC", // LLM-based understanding
  HYBRID = "HYBRID", // Both
}

export interface ClusterNode {
  id: string;
  name: string; // Cluster name or Note title
  type: "cluster" | "note";
  children?: ClusterNode[];
  noteId?: string; // If type is note
  description?: string; // Why this cluster exists
}

export interface SearchResult {
  note: Note;
  score: number;
  reason?: string; // Why matched (for semantic search)
  highlight?: string; // Snippet
}

export interface ProcessingStatus {
  isProcessing: boolean;
  message: string;
}

// --- Memory-Augmented Clustering Types ---

export interface ClusteringDecision {
  id: string;
  timestamp: number;
  noteIds: string[];
  clusterAssignments: Record<string, string>; // noteId -> clusterId
  clusterDescriptions: Record<string, string>; // clusterId -> description
  confidence: number; // 0-1, how confident the clustering was
  method: "initial" | "refinement" | "incremental";
}

export interface ClusteringMemory {
  decisions: ClusteringDecision[];
  lastClusteringTime: number;
  totalNotesProcessed: number;
  averageConfidence: number;
  version: string;
}

export interface MemoryBuffer {
  addDecision(decision: ClusteringDecision): void;
  getRecentDecisions(limit?: number): ClusteringDecision[];
  getDecisionById(id: string): ClusteringDecision | null;
  getMemoryForNotes(noteIds: string[]): ClusteringMemory;
  clearOldDecisions(keepLastN?: number): void;
  getStats(): {
    totalDecisions: number;
    avgConfidence: number;
    lastUpdate: number;
  };
}
// --- Embedding & Hybrid Clustering Types (Phase 2) ---

export interface NoteEmbedding {
  noteId: string;
  vector: number[]; // Dense embedding vector
  timestamp: number;
  modelUsed: string; // e.g., "gemini-embedding-001"
  textLength: number; // For caching decisions
}

export interface EmbeddingIndex {
  embeddings: NoteEmbedding[];
  lastUpdated: number;
  modelVersion: string;
  totalNotes: number;
}

export interface SimilarityPair {
  note1Id: string;
  note2Id: string;
  similarity: number; // 0-1, cosine similarity
}

export interface EmbeddingPartition {
  id: string;
  noteIds: string[];
  centroid?: number[]; // Average embedding
  silhouetteScore?: number; // Cluster quality metric
}
// --- Semantic Enhancement & Constraints (Phase 3) ---

export interface SemanticCentroid {
  clusterId: string;
  description: string; // LLM-generated semantic description
  keywords: string[]; // Key terms extracted/generated by LLM
  confidence: number; // 0-1, confidence in description
  embeddingVector?: number[]; // Embedding of the description
  generatedAt: number;
}

export interface HardSample {
  noteId: string;
  originalContent: string;
  ambiguityScore: number; // 0-1, how ambiguous this note is
  possibleClusters: string[]; // Candidate cluster IDs
  augmentedContent?: string; // LLM-rewritten version
  rewriteReason?: string;
}

export interface SupervisionSignal {
  id: string;
  type: "must-link" | "cannot-link"; // Constraint type
  note1Id: string;
  note2Id: string;
  strength: number; // 0-1, how strongly to enforce
  reason?: string;
  userProvided?: boolean; // Whether from user feedback
}

export interface ConstraintSet {
  mustLinkPairs: SupervisionSignal[];
  cannotLinkPairs: SupervisionSignal[];
  totalConstraints: number;
  totalNotesAffected: number;
}

export interface SemanticClusteringResult {
  clusters: ClusterNode[];
  centroids: Map<string, SemanticCentroid>;
  hardSamples: HardSample[];
  constraints: ConstraintSet;
  iterations: number;
  finalConfidence: number;
}
